// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace config {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2eproto();
void protobuf_AssignDesc_config_2eproto();
void protobuf_ShutdownFile_config_2eproto();

class Settings;
class Hikcam;
class Reef;
class Config;

enum Settings_AlgorithmMode {
  Settings_AlgorithmMode_DEFAULT = 0,
  Settings_AlgorithmMode_SNAPSHOT = 1,
  Settings_AlgorithmMode_HANDS_LOCATION = 2
};
bool Settings_AlgorithmMode_IsValid(int value);
const Settings_AlgorithmMode Settings_AlgorithmMode_AlgorithmMode_MIN = Settings_AlgorithmMode_DEFAULT;
const Settings_AlgorithmMode Settings_AlgorithmMode_AlgorithmMode_MAX = Settings_AlgorithmMode_HANDS_LOCATION;
const int Settings_AlgorithmMode_AlgorithmMode_ARRAYSIZE = Settings_AlgorithmMode_AlgorithmMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Settings_AlgorithmMode_descriptor();
inline const ::std::string& Settings_AlgorithmMode_Name(Settings_AlgorithmMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Settings_AlgorithmMode_descriptor(), value);
}
inline bool Settings_AlgorithmMode_Parse(
    const ::std::string& name, Settings_AlgorithmMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Settings_AlgorithmMode>(
    Settings_AlgorithmMode_descriptor(), name, value);
}
// ===================================================================

class Settings : public ::google::protobuf::Message {
 public:
  Settings();
  virtual ~Settings();

  Settings(const Settings& from);

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Settings& default_instance();

  void Swap(Settings* other);

  // implements Message ----------------------------------------------

  Settings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Settings& from);
  void MergeFrom(const Settings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Settings_AlgorithmMode AlgorithmMode;
  static const AlgorithmMode DEFAULT = Settings_AlgorithmMode_DEFAULT;
  static const AlgorithmMode SNAPSHOT = Settings_AlgorithmMode_SNAPSHOT;
  static const AlgorithmMode HANDS_LOCATION = Settings_AlgorithmMode_HANDS_LOCATION;
  static inline bool AlgorithmMode_IsValid(int value) {
    return Settings_AlgorithmMode_IsValid(value);
  }
  static const AlgorithmMode AlgorithmMode_MIN =
    Settings_AlgorithmMode_AlgorithmMode_MIN;
  static const AlgorithmMode AlgorithmMode_MAX =
    Settings_AlgorithmMode_AlgorithmMode_MAX;
  static const int AlgorithmMode_ARRAYSIZE =
    Settings_AlgorithmMode_AlgorithmMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AlgorithmMode_descriptor() {
    return Settings_AlgorithmMode_descriptor();
  }
  static inline const ::std::string& AlgorithmMode_Name(AlgorithmMode value) {
    return Settings_AlgorithmMode_Name(value);
  }
  static inline bool AlgorithmMode_Parse(const ::std::string& name,
      AlgorithmMode* value) {
    return Settings_AlgorithmMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float global_head_detect_thresh = 1 [default = 0.3];
  inline bool has_global_head_detect_thresh() const;
  inline void clear_global_head_detect_thresh();
  static const int kGlobalHeadDetectThreshFieldNumber = 1;
  inline float global_head_detect_thresh() const;
  inline void set_global_head_detect_thresh(float value);

  // optional float global_upperbody_detect_thresh = 2 [default = 0.3];
  inline bool has_global_upperbody_detect_thresh() const;
  inline void clear_global_upperbody_detect_thresh();
  static const int kGlobalUpperbodyDetectThreshFieldNumber = 2;
  inline float global_upperbody_detect_thresh() const;
  inline void set_global_upperbody_detect_thresh(float value);

  // required .config.Reef reef = 3;
  inline bool has_reef() const;
  inline void clear_reef();
  static const int kReefFieldNumber = 3;
  inline const ::config::Reef& reef() const;
  inline ::config::Reef* mutable_reef();
  inline ::config::Reef* release_reef();
  inline void set_allocated_reef(::config::Reef* reef);

  // optional bool enable_come_in = 4 [default = false];
  inline bool has_enable_come_in() const;
  inline void clear_enable_come_in();
  static const int kEnableComeInFieldNumber = 4;
  inline bool enable_come_in() const;
  inline void set_enable_come_in(bool value);

  // required string mask_path = 5;
  inline bool has_mask_path() const;
  inline void clear_mask_path();
  static const int kMaskPathFieldNumber = 5;
  inline const ::std::string& mask_path() const;
  inline void set_mask_path(const ::std::string& value);
  inline void set_mask_path(const char* value);
  inline void set_mask_path(const char* value, size_t size);
  inline ::std::string* mutable_mask_path();
  inline ::std::string* release_mask_path();
  inline void set_allocated_mask_path(::std::string* mask_path);

  // optional .config.Settings.AlgorithmMode algorithm_mode = 6 [default = DEFAULT];
  inline bool has_algorithm_mode() const;
  inline void clear_algorithm_mode();
  static const int kAlgorithmModeFieldNumber = 6;
  inline ::config::Settings_AlgorithmMode algorithm_mode() const;
  inline void set_algorithm_mode(::config::Settings_AlgorithmMode value);

  // optional bool capture_only = 7 [default = false];
  inline bool has_capture_only() const;
  inline void clear_capture_only();
  static const int kCaptureOnlyFieldNumber = 7;
  inline bool capture_only() const;
  inline void set_capture_only(bool value);

  // @@protoc_insertion_point(class_scope:config.Settings)
 private:
  inline void set_has_global_head_detect_thresh();
  inline void clear_has_global_head_detect_thresh();
  inline void set_has_global_upperbody_detect_thresh();
  inline void clear_has_global_upperbody_detect_thresh();
  inline void set_has_reef();
  inline void clear_has_reef();
  inline void set_has_enable_come_in();
  inline void clear_has_enable_come_in();
  inline void set_has_mask_path();
  inline void clear_has_mask_path();
  inline void set_has_algorithm_mode();
  inline void clear_has_algorithm_mode();
  inline void set_has_capture_only();
  inline void clear_has_capture_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float global_head_detect_thresh_;
  float global_upperbody_detect_thresh_;
  ::config::Reef* reef_;
  ::std::string* mask_path_;
  bool enable_come_in_;
  bool capture_only_;
  int algorithm_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Settings* default_instance_;
};
// -------------------------------------------------------------------

class Hikcam : public ::google::protobuf::Message {
 public:
  Hikcam();
  virtual ~Hikcam();

  Hikcam(const Hikcam& from);

  inline Hikcam& operator=(const Hikcam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hikcam& default_instance();

  void Swap(Hikcam* other);

  // implements Message ----------------------------------------------

  Hikcam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hikcam& from);
  void MergeFrom(const Hikcam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 store_id = 1;
  inline bool has_store_id() const;
  inline void clear_store_id();
  static const int kStoreIdFieldNumber = 1;
  inline ::google::protobuf::int32 store_id() const;
  inline void set_store_id(::google::protobuf::int32 value);

  // required int32 camera_id = 2;
  inline bool has_camera_id() const;
  inline void clear_camera_id();
  static const int kCameraIdFieldNumber = 2;
  inline ::google::protobuf::int32 camera_id() const;
  inline void set_camera_id(::google::protobuf::int32 value);

  // required string ip_address = 4;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 4;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const char* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required .config.Settings settings = 7;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 7;
  inline const ::config::Settings& settings() const;
  inline ::config::Settings* mutable_settings();
  inline ::config::Settings* release_settings();
  inline void set_allocated_settings(::config::Settings* settings);

  // optional string desc = 8 [default = "Brief description of this HikCamera"];
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 8;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:config.Hikcam)
 private:
  inline void set_has_store_id();
  inline void clear_has_store_id();
  inline void set_has_camera_id();
  inline void clear_has_camera_id();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_settings();
  inline void clear_has_settings();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 store_id_;
  ::google::protobuf::int32 camera_id_;
  ::std::string* ip_address_;
  ::std::string* name_;
  ::std::string* password_;
  ::config::Settings* settings_;
  ::std::string* desc_;
  static ::std::string* _default_desc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Hikcam* default_instance_;
};
// -------------------------------------------------------------------

class Reef : public ::google::protobuf::Message {
 public:
  Reef();
  virtual ~Reef();

  Reef(const Reef& from);

  inline Reef& operator=(const Reef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reef& default_instance();

  void Swap(Reef* other);

  // implements Message ----------------------------------------------

  Reef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reef& from);
  void MergeFrom(const Reef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1 [default = -1];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2 [default = -1];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:config.Reef)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Reef* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .config.Hikcam camera = 1;
  inline int camera_size() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 1;
  inline const ::config::Hikcam& camera(int index) const;
  inline ::config::Hikcam* mutable_camera(int index);
  inline ::config::Hikcam* add_camera();
  inline const ::google::protobuf::RepeatedPtrField< ::config::Hikcam >&
      camera() const;
  inline ::google::protobuf::RepeatedPtrField< ::config::Hikcam >*
      mutable_camera();

  // @@protoc_insertion_point(class_scope:config.Config)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::config::Hikcam > camera_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// ===================================================================


// ===================================================================

// Settings

// optional float global_head_detect_thresh = 1 [default = 0.3];
inline bool Settings::has_global_head_detect_thresh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Settings::set_has_global_head_detect_thresh() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Settings::clear_has_global_head_detect_thresh() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Settings::clear_global_head_detect_thresh() {
  global_head_detect_thresh_ = 0.3f;
  clear_has_global_head_detect_thresh();
}
inline float Settings::global_head_detect_thresh() const {
  return global_head_detect_thresh_;
}
inline void Settings::set_global_head_detect_thresh(float value) {
  set_has_global_head_detect_thresh();
  global_head_detect_thresh_ = value;
}

// optional float global_upperbody_detect_thresh = 2 [default = 0.3];
inline bool Settings::has_global_upperbody_detect_thresh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Settings::set_has_global_upperbody_detect_thresh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Settings::clear_has_global_upperbody_detect_thresh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Settings::clear_global_upperbody_detect_thresh() {
  global_upperbody_detect_thresh_ = 0.3f;
  clear_has_global_upperbody_detect_thresh();
}
inline float Settings::global_upperbody_detect_thresh() const {
  return global_upperbody_detect_thresh_;
}
inline void Settings::set_global_upperbody_detect_thresh(float value) {
  set_has_global_upperbody_detect_thresh();
  global_upperbody_detect_thresh_ = value;
}

// required .config.Reef reef = 3;
inline bool Settings::has_reef() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Settings::set_has_reef() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Settings::clear_has_reef() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Settings::clear_reef() {
  if (reef_ != NULL) reef_->::config::Reef::Clear();
  clear_has_reef();
}
inline const ::config::Reef& Settings::reef() const {
  return reef_ != NULL ? *reef_ : *default_instance_->reef_;
}
inline ::config::Reef* Settings::mutable_reef() {
  set_has_reef();
  if (reef_ == NULL) reef_ = new ::config::Reef;
  return reef_;
}
inline ::config::Reef* Settings::release_reef() {
  clear_has_reef();
  ::config::Reef* temp = reef_;
  reef_ = NULL;
  return temp;
}
inline void Settings::set_allocated_reef(::config::Reef* reef) {
  delete reef_;
  reef_ = reef;
  if (reef) {
    set_has_reef();
  } else {
    clear_has_reef();
  }
}

// optional bool enable_come_in = 4 [default = false];
inline bool Settings::has_enable_come_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Settings::set_has_enable_come_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Settings::clear_has_enable_come_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Settings::clear_enable_come_in() {
  enable_come_in_ = false;
  clear_has_enable_come_in();
}
inline bool Settings::enable_come_in() const {
  return enable_come_in_;
}
inline void Settings::set_enable_come_in(bool value) {
  set_has_enable_come_in();
  enable_come_in_ = value;
}

// required string mask_path = 5;
inline bool Settings::has_mask_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Settings::set_has_mask_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Settings::clear_has_mask_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Settings::clear_mask_path() {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    mask_path_->clear();
  }
  clear_has_mask_path();
}
inline const ::std::string& Settings::mask_path() const {
  return *mask_path_;
}
inline void Settings::set_mask_path(const ::std::string& value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void Settings::set_mask_path(const char* value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void Settings::set_mask_path(const char* value, size_t size) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Settings::mutable_mask_path() {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  return mask_path_;
}
inline ::std::string* Settings::release_mask_path() {
  clear_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mask_path_;
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Settings::set_allocated_mask_path(::std::string* mask_path) {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    delete mask_path_;
  }
  if (mask_path) {
    set_has_mask_path();
    mask_path_ = mask_path;
  } else {
    clear_has_mask_path();
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .config.Settings.AlgorithmMode algorithm_mode = 6 [default = DEFAULT];
inline bool Settings::has_algorithm_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Settings::set_has_algorithm_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Settings::clear_has_algorithm_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Settings::clear_algorithm_mode() {
  algorithm_mode_ = 0;
  clear_has_algorithm_mode();
}
inline ::config::Settings_AlgorithmMode Settings::algorithm_mode() const {
  return static_cast< ::config::Settings_AlgorithmMode >(algorithm_mode_);
}
inline void Settings::set_algorithm_mode(::config::Settings_AlgorithmMode value) {
  assert(::config::Settings_AlgorithmMode_IsValid(value));
  set_has_algorithm_mode();
  algorithm_mode_ = value;
}

// optional bool capture_only = 7 [default = false];
inline bool Settings::has_capture_only() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Settings::set_has_capture_only() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Settings::clear_has_capture_only() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Settings::clear_capture_only() {
  capture_only_ = false;
  clear_has_capture_only();
}
inline bool Settings::capture_only() const {
  return capture_only_;
}
inline void Settings::set_capture_only(bool value) {
  set_has_capture_only();
  capture_only_ = value;
}

// -------------------------------------------------------------------

// Hikcam

// required int32 store_id = 1;
inline bool Hikcam::has_store_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hikcam::set_has_store_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hikcam::clear_has_store_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hikcam::clear_store_id() {
  store_id_ = 0;
  clear_has_store_id();
}
inline ::google::protobuf::int32 Hikcam::store_id() const {
  return store_id_;
}
inline void Hikcam::set_store_id(::google::protobuf::int32 value) {
  set_has_store_id();
  store_id_ = value;
}

// required int32 camera_id = 2;
inline bool Hikcam::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hikcam::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hikcam::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hikcam::clear_camera_id() {
  camera_id_ = 0;
  clear_has_camera_id();
}
inline ::google::protobuf::int32 Hikcam::camera_id() const {
  return camera_id_;
}
inline void Hikcam::set_camera_id(::google::protobuf::int32 value) {
  set_has_camera_id();
  camera_id_ = value;
}

// required string ip_address = 4;
inline bool Hikcam::has_ip_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hikcam::set_has_ip_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hikcam::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hikcam::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& Hikcam::ip_address() const {
  return *ip_address_;
}
inline void Hikcam::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void Hikcam::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void Hikcam::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hikcam::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  return ip_address_;
}
inline ::std::string* Hikcam::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hikcam::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 5;
inline bool Hikcam::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hikcam::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hikcam::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hikcam::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Hikcam::name() const {
  return *name_;
}
inline void Hikcam::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Hikcam::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Hikcam::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hikcam::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Hikcam::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hikcam::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 6;
inline bool Hikcam::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hikcam::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hikcam::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hikcam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Hikcam::password() const {
  return *password_;
}
inline void Hikcam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Hikcam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Hikcam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hikcam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Hikcam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hikcam::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .config.Settings settings = 7;
inline bool Hikcam::has_settings() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hikcam::set_has_settings() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hikcam::clear_has_settings() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hikcam::clear_settings() {
  if (settings_ != NULL) settings_->::config::Settings::Clear();
  clear_has_settings();
}
inline const ::config::Settings& Hikcam::settings() const {
  return settings_ != NULL ? *settings_ : *default_instance_->settings_;
}
inline ::config::Settings* Hikcam::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) settings_ = new ::config::Settings;
  return settings_;
}
inline ::config::Settings* Hikcam::release_settings() {
  clear_has_settings();
  ::config::Settings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline void Hikcam::set_allocated_settings(::config::Settings* settings) {
  delete settings_;
  settings_ = settings;
  if (settings) {
    set_has_settings();
  } else {
    clear_has_settings();
  }
}

// optional string desc = 8 [default = "Brief description of this HikCamera"];
inline bool Hikcam::has_desc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Hikcam::set_has_desc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Hikcam::clear_has_desc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Hikcam::clear_desc() {
  if (desc_ != _default_desc_) {
    desc_->assign(*_default_desc_);
  }
  clear_has_desc();
}
inline const ::std::string& Hikcam::desc() const {
  return *desc_;
}
inline void Hikcam::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Hikcam::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Hikcam::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hikcam::mutable_desc() {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string(*_default_desc_);
  }
  return desc_;
}
inline ::std::string* Hikcam::release_desc() {
  clear_has_desc();
  if (desc_ == _default_desc_) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(_default_desc_);
    return temp;
  }
}
inline void Hikcam::set_allocated_desc(::std::string* desc) {
  if (desc_ != _default_desc_) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(_default_desc_);
  }
}

// -------------------------------------------------------------------

// Reef

// required int32 x = 1 [default = -1];
inline bool Reef::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reef::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reef::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reef::clear_x() {
  x_ = -1;
  clear_has_x();
}
inline ::google::protobuf::int32 Reef::x() const {
  return x_;
}
inline void Reef::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2 [default = -1];
inline bool Reef::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reef::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reef::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reef::clear_y() {
  y_ = -1;
  clear_has_y();
}
inline ::google::protobuf::int32 Reef::y() const {
  return y_;
}
inline void Reef::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Config

// repeated .config.Hikcam camera = 1;
inline int Config::camera_size() const {
  return camera_.size();
}
inline void Config::clear_camera() {
  camera_.Clear();
}
inline const ::config::Hikcam& Config::camera(int index) const {
  return camera_.Get(index);
}
inline ::config::Hikcam* Config::mutable_camera(int index) {
  return camera_.Mutable(index);
}
inline ::config::Hikcam* Config::add_camera() {
  return camera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::config::Hikcam >&
Config::camera() const {
  return camera_;
}
inline ::google::protobuf::RepeatedPtrField< ::config::Hikcam >*
Config::mutable_camera() {
  return &camera_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::config::Settings_AlgorithmMode>() {
  return ::config::Settings_AlgorithmMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
